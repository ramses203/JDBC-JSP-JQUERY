// Generated by CoffeeScript 1.12.1
(function() {
  'use strict';
  var apirequest, clickableElements, createElementName, emit, emitSession, endpoint, event, events, i, inputElements, inputonblur, isBot, len, pxtrack, session, sessionSpacing, strLastActivity, time, token;

  isBot = /bot|googlebot|crawler|spider|robot|crawling/i.test(navigator.userAgent);

  if (isBot) {
    return;
  }


  /*
   * cookie-monster - a simple cookie library
   * v0.3.0
   * https://github.com/jgallen23/cookie-monster
   * copyright Greg Allen 2014
   * MIT License
   */

  var monster = {
  set: function(name, value, days, path, secure) {
    var date = new Date(),
        expires = '',
        type = typeof(value),
        valueToUse = '',
        secureFlag = '';
    path = path || "/";
    if (days) {
      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
      expires = "; expires=" + date.toUTCString();
    }
    if (type === "object"  && type !== "undefined") {
        if(!("JSON" in window)) throw "Bummer, your browser doesn't support JSON parsing.";
        valueToUse = encodeURIComponent(JSON.stringify({v:value}));
    } else {
      valueToUse = encodeURIComponent(value);
    }
    if (secure){
      secureFlag = "; secure";
    }

    document.cookie = name + "=" + valueToUse + expires + "; path=" + path + secureFlag;
  },
  get: function(name) {
    var nameEQ = name + "=",
        ca = document.cookie.split(';'),
        value = '',
        firstChar = '',
        parsed={};
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) == ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) {
        value = decodeURIComponent(c.substring(nameEQ.length, c.length));
        firstChar = value.substring(0, 1);
        if(firstChar=="{"){
          try {
            parsed = JSON.parse(value);
            if("v" in parsed) return parsed.v;
          } catch(e) {
            return value;
          }
        }
        if (value=="undefined") return undefined;
        return value;
      }
    }
    return null;
  },
  remove: function(name) {
    this.set(name, "", -1);
  },
  increment: function(name, days) {
    var value = this.get(name) || 0;
    this.set(name, (parseInt(value, 10) + 1), days);
  },
  decrement: function(name, days) {
    var value = this.get(name) || 0;
    this.set(name, (parseInt(value, 10) - 1), days);
  }
};;

  (function(win, doc){
	if(win.addEventListener)return;		//No need to polyfill

	function docHijack(p){var old = doc[p];doc[p] = function(v){return addListen(old(v))}}
	function addEvent(on, fn, self){
		return (self = this).attachEvent('on' + on, function(e){
			var e = e || win.event;
			e.preventDefault  = e.preventDefault  || function(){e.returnValue = false}
			e.stopPropagation = e.stopPropagation || function(){e.cancelBubble = true}
			fn.call(self, e);
		});
	}
	function addListen(obj, i){
		if(i = obj.length)while(i--)obj[i].addEventListener = addEvent;
		else obj.addEventListener = addEvent;
		return obj;
	}

	addListen([doc, win]);
	if('Element' in win)win.Element.prototype.addEventListener = addEvent;			//IE8
	else{																			//IE < 8
		doc.attachEvent('onreadystatechange', function(){addListen(doc.all)});		//Make sure we also init at domReady
		docHijack('getElementsByTagName');
		docHijack('getElementById');
		docHijack('createElement');
		addListen(doc.all);	
	}
})(window, document);;

  token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoxLCJ0aXRsZSI6ImNvZGVwZW4uaW8gaGl0cyIsImlhdCI6MTQ1ODYwMzAzNX0.iveKvifh0UE3q-1ym6_nvyQ_4cJu_ewGPhrt5eTCicQ';

  endpoint = 'http://pxtrack.herokuapp.com/api';

  session = '1635468661296_::ffff:10.1.47.132';

  sessionSpacing = 900000;

  strLastActivity = 'pxtrack_last_activity';

  clickableElements = ['button', 'a'];

  inputElements = ['input', 'textarea'];

  events = {
    button: ['click'],
    input: ['input']
  };

  pxtrack = {
    sendError: false,
    console: {
      error: window.console.error,
      log: window.console.log,
      info: window.console.info
    },
    log: [],
    emit: (function(_this) {
      return function(type, options, moreoptions) {
        if (options == null) {
          options = {};
        }
        if (moreoptions == null) {
          moreoptions = {};
        }
        if (type === 'message') {
          return emit.message({
            text: options.text || '',
            tags: options.tags || [],
            meta: options.meta || {},
            token: token
          });
        } else if (type === 'error') {
          return emit.error({
            text: options.text || '',
            tags: options.tags || [],
            meta: options.meta || {},
            log: options.log || [],
            session: session,
            token: token
          });
        } else if (type === 'counter') {
          return emit.counter(options, {
            meta: moreoptions.meta
          });
        } else {
          return console.log('pxTrack: Cannot emit \'' + type + '\' as it isn\'t valid type of request');
        }
      };
    })(this)
  };

  apirequest = (function(_this) {
    return function(path, obj) {
      var req;
      req = new XMLHttpRequest();
      req.open('POST', endpoint + path);
      req.setRequestHeader('Content-Type', 'application/json');
      req.setRequestHeader('Accept', 'application/json, text/plain, */*');
      req.addEventListener('readystatechange', function() {});
      return req.send(JSON.stringify(obj));
    };
  })(this);

  emitSession = (function(_this) {
    return function() {
      if (new Date() - new Date(monster.get(strLastActivity)) > sessionSpacing) {
        apirequest('/d/session', {
          token: token
        });
      }
      return monster.set(strLastActivity, new Date());
    };
  })(this);

  emitSession();

  createElementName = (function(_this) {
    return function(element) {
      var elementName;
      if (!element) {
        return false;
      }
      elementName = element.nodeName;
      elementName += element.id ? '#' + element.id : '';
      elementName += element.className ? '.' + element.className.replace(' ', '.') : '';
      return elementName;
    };
  })(this);

  events = ['scroll', 'mousemove', 'resize', 'click', 'keydown', 'keypress'];

  for (i = 0, len = events.length; i < len; i++) {
    event = events[i];
    window.addEventListener(event, emitSession());
  }

  window.addEventListener('click', (function(_this) {
    return function(event) {
      if (!event.srcElement) {
        return false;
      }
      if (clickableElements.indexOf(event.srcElement.nodeName.toLowerCase()) === -1) {
        return false;
      }
      return pxtrack.log.push({
        type: 'action.click',
        time: time.getPageTime(),
        message: 'Click on ' + createElementName(event.srcElement)
      });
    };
  })(this));

  inputonblur = (function(_this) {
    return function(event) {
      return pxtrack.log.push({
        type: 'action.input',
        time: time.getPageTime(),
        message: 'Input on ' + createElementName(event.srcElement)
      });
    };
  })(this);

  window.addEventListener('keydown', (function(_this) {
    return function(event) {
      if (!event.srcElement) {
        return false;
      }
      if (inputElements.indexOf(event.srcElement.nodeName.toLowerCase()) === -1) {
        return false;
      }
      event.srcElement.removeEventListener('blur', inputonblur);
      return event.srcElement.addEventListener('blur', inputonblur);
    };
  })(this));

  emit = {
    message: (function(_this) {
      return function(message) {
        return apirequest('/d/message', message);
      };
    })(this),
    error: (function(_this) {
      return function(error) {
        return apirequest('/d/error', error);
      };
    })(this),
    counter: (function(_this) {
      return function(counter_id, meta) {
        return apirequest('/d/counter/' + counter_id, meta);
      };
    })(this)
  };

  time = {
    init: new Date(),
    getPageTime: (function(_this) {
      return function() {
        return (new Date()) - time.init;
      };
    })(this)
  };

  window.onerror = (function(_this) {
    return function(errorMsg, url, lineNumber, columnNumber, error) {
      pxtrack.sendError = true;
      pxtrack.log.push({
        type: 'error',
        info: arguments,
        message: errorMsg,
        url: url,
        lineNumber: lineNumber,
        columnNumber: columnNumber,
        time: time.getPageTime(),
        error: {
          message: error.message,
          stack: error.stack
        }
      });
      pxtrack.emit('error', {
        text: errorMsg,
        tags: ['generated'],
        meta: null,
        log: pxtrack.log
      });
      pxtrack.console.error.apply(console, arguments);
      return true;
    };
  })(this);

  window.console.error = (function(_this) {
    return function() {
      var error, message;
      pxtrack.sendError = true;
      pxtrack.console.error.apply(console, arguments);
      error = Error.apply(new Error(), arguments);
      message = error.message.split(/\sat/g)[0];
      pxtrack.log.push({
        type: 'error',
        info: arguments,
        message: message,
        time: time.getPageTime(),
        error: {
          message: message,
          stack: error.stack
        }
      });
      return pxtrack.emit('error', {
        text: message,
        tags: ['console.error'],
        meta: null,
        log: pxtrack.log
      });
    };
  })(this);

  window.console.log = (function(_this) {
    return function() {
      pxtrack.console.log.apply(console, arguments);
      return pxtrack.log.push({
        type: 'log',
        info: arguments,
        message: [].join.call(arguments, ' '),
        time: time.getPageTime()
      });
    };
  })(this);

  window.console.info = (function(_this) {
    return function() {
      pxtrack.console.info.apply(console, arguments);
      return pxtrack.log.push({
        type: 'info',
        info: arguments,
        message: [].join.call(arguments, ' '),
        time: time.getPageTime()
      });
    };
  })(this);

  window.pxtrack = pxtrack;

}).call(this);
